#!/bin/bash

# Determine if we are running on macOS
is_osx() {
  local platform
  platform=$(uname)
  [ "$platform" == "Darwin" ]
}

# Start an HTTP server from a directory, optionally specifying the port
server() {
  local port="${1:-8000}"
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
tre() {
  tree -aC -I '.git' --dirsfirst "$@" | less -FRNX
}

# Call from a local repo to open the repository on github/bitbucket in browser
repo() {
  local giturl
  giturl=$(git config --get remote.origin.url | sed 's/git@/\/\//g' | sed 's/.git$//' | sed 's/https://g' | sed 's/:/\//g')
  if [[ $giturl == "" ]]; then
  echo "Not a git repository or no remote.origin.url is set."
  else
  local gitbranch
  gitbranch=$(git rev-parse --abbrev-ref HEAD)
  local giturl="http:${giturl}"

  if [[ $gitbranch != "${DEFAULT_GIT_BRANCH}" ]]; then
  if echo "${giturl}" | grep -i "bitbucket" > /dev/null ; then
  local giturl="${giturl}/branch/${gitbranch}"
  else
  local giturl="${giturl}/tree/${gitbranch}"
  fi
  fi

  echo "$giturl"
  open "$giturl" > /dev/null 2>&1
  fi
}

# Get colors in manual pages
man() {
	env \
		LESS_TERMCAP_mb="$(printf '\e[1;31m')" \
		LESS_TERMCAP_md="$(printf '\e[1;31m')" \
		LESS_TERMCAP_me="$(printf '\e[0m')" \
		LESS_TERMCAP_se="$(printf '\e[0m')" \
		LESS_TERMCAP_so="$(printf '\e[1;44;33m')" \
		LESS_TERMCAP_ue="$(printf '\e[0m')" \
		LESS_TERMCAP_us="$(printf '\e[1;32m')" \
		man "$@"
}

spinner() {
  chars="/-\|"

  while :; do
    for (( i=0; i<${#chars}; i++ )); do
      sleep 0.5
      echo -en "${chars:$i:1}" "\r"
    done
  done
}

dtty() {
  screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty
}

dog() {
  pred='process matches ".*(ocker|vpnkit).*" || (process in {"taskgated-helper", "launchservicesd", "kernel"} && eventMessage contains[c] "docker")'
  /usr/bin/log stream --style syslog --level=debug --color=always --predicate "$pred"
}

cda() {
  cd "${HOME}/code/artsy/${*}" || exit
}

dcb() {
  docker-compose build --no-cache
}

dce() {
  COMMAND=${1}
  SERVICE=${PWD##*/}
  echo "docker-compose exec ${SERVICE} ${COMMAND}"
  docker-compose exec "${SERVICE}" "${COMMAND}"
}

dcl() {
  docker-compose logs --tail=50 --follow
}

dclearunused() {
  docker images | grep none | awk '{print $3}' | while read -r sha; do echo "Removing docker image $sha"; docker rmi "$sha"; done
}

migrate() {
  (
    il
    ./utils/run.sh migrations edge-gateway=all
  )
}

morning() {
  il && \
  osascript -e "quit app \"Docker\"" && \
  git pull && \
  open --background -a Docker && \
  while ! docker system info > /dev/null 2>&1; do echo "Waiting for docker..."; sleep 10; done && \
  migrate && \
  docker-compose up -d && \
  docker system prune --all --volumes --force && \
  echo 'done'
}

android() {
  export ANDROID_SDK=$HOME/Library/Android/sdk
  export PATH=$ANDROID_SDK/emulator:$ANDROID_SDK/tools:$PATH
  emulator -avd Okta
  unset ANDROID_SDK
  unset export
}

show-colors() {
  for i in {0..256}; do
    echo -e "${i} \033[38;05;${i}m COLOR \033[0m"
  done
}

# Hokusai

hokusai_get_env() {
  echo "Looking up ${1} in ${2:-staging}"
  hokusai "${2:-staging}" env get | grep "${1}"
}
